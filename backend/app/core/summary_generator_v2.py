"""
Summary Generator V2 - Production lease summary generation module

This module processes enriched chunks from the recursive GPT-based chunker to generate
clean text summaries and CSV exports for the LeaseLogic platform.

Author: Senior Backend Engineer
Version: 2.0
"""

from typing import List, Dict, Any, Set, Tuple
import os
import openai
import asyncio
import json
from app.utils.logger import logger
from app.core.summary_generator_dynamic import generate_dynamic_summary


def generate_markdown_summary(chunks: List[Dict[str, Any]]) -> str:
    """
    Generate a clean, readable lease summary from enriched chunks using GPT-4.
    Now uses dynamic summary generation that adapts to any lease structure.
    
    Args:
        chunks: List of enriched chunk dictionaries from the GPT chunker
        
    Returns:
        Formatted text string containing the complete lease summary
    """
    if not chunks:
        return "Lease Summary\n\nNo lease data available for processing\n"
    
    # Check if GPT should be used or if we should use dynamic generation
    use_gpt = os.environ.get("USE_GPT_SUMMARY", "false").lower() == "true"
    
    if use_gpt:
        try:
            # Check if we're already in an event loop
            try:
                loop = asyncio.get_running_loop()
                # We're in an async context, use sync version
                summary = _generate_gpt_summary_sync(chunks)
                return summary
            except RuntimeError:
                # No event loop running, we can use asyncio.run
                summary = asyncio.run(_generate_gpt_summary(chunks))
                return summary
        except Exception as e:
            logger.error(f"Error generating GPT summary: {str(e)}")
            logger.info("Falling back to dynamic summary generation")
    
    # Use the new dynamic summary generator
    return generate_dynamic_summary(chunks)


def _generate_gpt_summary_sync(chunks: List[Dict[str, Any]]) -> str:
    """
    Synchronous version of GPT summary generation.
    
    Args:
        chunks: List of enriched chunk dictionaries
        
    Returns:
        Professional lease summary generated by GPT
    """
    # System prompt for GPT summarization
    system_prompt = """You are acting as a senior real estate analyst preparing a client-ready lease summary. Your job is to produce a clean, copy-and-pasteable lease summary for a memo, report, or email. Use natural, professional English. Organize information into sections. Convert key values into readable policy-style statements. Flatten nested structures into plain English. Highlight risks only if severity is medium or high. Mark low-confidence clauses with a note to verify wording. If any standard clause category is missing, note it in the final section. Return only the polished summary — no formatting syntax, no markdown."""
    
    # Group chunks by clause type for better organization
    grouped_chunks = {}
    seen_categories = set()
    
    for chunk in chunks:
        clause_hint = chunk.get("clause_hint", "unknown")
        seen_categories.add(clause_hint)
        
        if clause_hint not in grouped_chunks:
            grouped_chunks[clause_hint] = []
        grouped_chunks[clause_hint].append(chunk)
    
    # Prepare structured data for GPT
    sections_data = {}
    for clause_type, clause_chunks in grouped_chunks.items():
        section_data = {
            "clauses": []
        }
        
        for chunk in clause_chunks:
            clause_info = {
                "key_values": chunk.get("key_values", {}),
                "confidence": chunk.get("confidence", 1.0),
                "page_range": _format_page_range(chunk.get("page_start"), chunk.get("page_end")),
                "truncated": chunk.get("truncated", False)
            }
            
            # Only include medium and high risk flags
            risk_flags = chunk.get("risk_flags", [])
            relevant_risks = [r for r in risk_flags if r.get("risk_level", "").lower() in ["medium", "high"]]
            if relevant_risks:
                clause_info["risks"] = relevant_risks
            
            section_data["clauses"].append(clause_info)
        
        sections_data[clause_type] = section_data
    
    # Detect missing standard clauses
    standard_clauses = {"premises", "term", "rent", "maintenance", "use", "assignment", 
                       "insurance", "default", "casualty", "entry", "eminent_domain", 
                       "notices", "governing_law"}
    missing_clauses = []
    
    for std_clause in standard_clauses:
        found = any(std_clause in cat.lower() for cat in seen_categories)
        if not found:
            missing_clauses.append(std_clause.replace("_", " ").title())
    
    # Create user prompt with structured data
    user_prompt = (
        "Please generate a professional lease summary from the following extracted lease data. "
        "Group related information logically and present it in clear, professional prose. "
        "Remember to note any low-confidence extractions and list missing standard clauses at the end.\n\n"
        "Extracted Lease Data:\n" + json.dumps(sections_data, indent=2) + "\n\n"
        "Missing Standard Clauses:\n" + json.dumps(missing_clauses) + "\n\n"
        "Please provide the summary in plain text format without any markdown or formatting symbols."
    )
    
    # Get OpenAI API key
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OpenAI API key not found in environment variables")
    
    # Make GPT API call
    try:
        client = openai.OpenAI(api_key=api_key)
        response = client.chat.completions.create(
            model="gpt-4",  # Using GPT-4 as requested
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,  # Low temperature for consistent, factual output
            max_tokens=4000   # Sufficient for comprehensive summary
        )
        
        summary = response.choices[0].message.content
        logger.info("Successfully generated GPT-powered lease summary")
        return summary
        
    except Exception as e:
        logger.error(f"GPT API call failed: {str(e)}")
        raise


async def _generate_gpt_summary(chunks: List[Dict[str, Any]]) -> str:
    """
    Generate lease summary using GPT-4 with the professional system prompt.
    
    Args:
        chunks: List of enriched chunk dictionaries
        
    Returns:
        Professional lease summary generated by GPT
    """
    # System prompt for GPT summarization
    system_prompt = """You are acting as a senior real estate analyst preparing a client-ready lease summary. Your job is to produce a clean, copy-and-pasteable lease summary for a memo, report, or email. Use natural, professional English. Organize information into sections. Convert key values into readable policy-style statements. Flatten nested structures into plain English. Highlight risks only if severity is medium or high. Mark low-confidence clauses with a note to verify wording. If any standard clause category is missing, note it in the final section. Return only the polished summary — no formatting syntax, no markdown."""
    
    # Group chunks by clause type for better organization
    grouped_chunks = {}
    seen_categories = set()
    
    for chunk in chunks:
        clause_hint = chunk.get("clause_hint", "unknown")
        seen_categories.add(clause_hint)
        
        if clause_hint not in grouped_chunks:
            grouped_chunks[clause_hint] = []
        grouped_chunks[clause_hint].append(chunk)
    
    # Prepare structured data for GPT
    sections_data = {}
    for clause_type, clause_chunks in grouped_chunks.items():
        section_data = {
            "clauses": []
        }
        
        for chunk in clause_chunks:
            clause_info = {
                "key_values": chunk.get("key_values", {}),
                "confidence": chunk.get("confidence", 1.0),
                "page_range": _format_page_range(chunk.get("page_start"), chunk.get("page_end")),
                "truncated": chunk.get("truncated", False)
            }
            
            # Only include medium and high risk flags
            risk_flags = chunk.get("risk_flags", [])
            relevant_risks = [r for r in risk_flags if r.get("risk_level", "").lower() in ["medium", "high"]]
            if relevant_risks:
                clause_info["risks"] = relevant_risks
            
            section_data["clauses"].append(clause_info)
        
        sections_data[clause_type] = section_data
    
    # Detect missing standard clauses
    standard_clauses = {"premises", "term", "rent", "maintenance", "use", "assignment", 
                       "insurance", "default", "casualty", "entry", "eminent_domain", 
                       "notices", "governing_law"}
    missing_clauses = []
    
    for std_clause in standard_clauses:
        found = any(std_clause in cat.lower() for cat in seen_categories)
        if not found:
            missing_clauses.append(std_clause.replace("_", " ").title())
    
    # Create user prompt with structured data
    user_prompt = (
        "Please generate a professional lease summary from the following extracted lease data. "
        "Group related information logically and present it in clear, professional prose. "
        "Remember to note any low-confidence extractions and list missing standard clauses at the end.\n\n"
        "Extracted Lease Data:\n" + json.dumps(sections_data, indent=2) + "\n\n"
        "Missing Standard Clauses:\n" + json.dumps(missing_clauses) + "\n\n"
        "Please provide the summary in plain text format without any markdown or formatting symbols."
    )
    
    # Get OpenAI API key
    api_key = os.environ.get("OPENAI_API_KEY")
    if not api_key:
        raise ValueError("OpenAI API key not found in environment variables")
    
    # Make GPT API call
    try:
        def sync_openai_call():
            client = openai.OpenAI(api_key=api_key)
            response = client.chat.completions.create(
                model="gpt-4",  # Using GPT-4 as requested
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.3,  # Low temperature for consistent, factual output
                max_tokens=4000   # Sufficient for comprehensive summary
            )
            return response.choices[0].message.content
        
        # Run sync call in thread pool to make it async
        import concurrent.futures
        loop = asyncio.get_event_loop()
        with concurrent.futures.ThreadPoolExecutor() as executor:
            future = loop.run_in_executor(executor, sync_openai_call)
            summary = await asyncio.wait_for(future, timeout=120)  # 2 minute timeout
        
        logger.info("Successfully generated GPT-powered lease summary")
        return summary
        
    except Exception as e:
        logger.error(f"GPT API call failed: {str(e)}")
        raise


def _generate_template_summary(chunks: List[Dict[str, Any]]) -> str:
    """
    Generate a template-based summary as fallback when GPT is unavailable.
    Returns plain text format without markdown.
    
    Args:
        chunks: List of enriched chunk dictionaries
        
    Returns:
        Plain text lease summary
    """
    # Check if this is a failed extraction
    if len(chunks) == 1 and chunks[0].get("clause_hint") == "document_info":
        if chunks[0].get("key_values", {}).get("extraction_failed"):
            return """LEASE SUMMARY

Document Processing Status: Failed

The automated extraction system was unable to extract lease clauses from this document.

Possible reasons:
• The document may be heavily scanned or have poor text quality
• The lease format may be non-standard
• The document may be incomplete or corrupted

Recommendations:
• Verify the document is a complete lease agreement
• Check if the PDF has selectable text (not just scanned images)
• Consider manual review of the document
• Contact support if the issue persists

Document Information:
• Type: Lease agreement (validated)
• Processing attempted but no clauses could be extracted
• Manual review is required to extract lease terms
"""
    
    sections = {
        "overview": [],
        "term": [],
        "rent": [],
        "additional": [],
        "maintenance": [],
        "assignment": [],
        "use": [],
        "insurance": [],
        "casualty": [],
        "legal": [],
        "other": []
    }
    
    all_risks = []
    seen_categories = set()
    
    # Process and categorize chunks
    for chunk in chunks:
        clause_hint = chunk.get("clause_hint", "").lower()
        key_values = chunk.get("key_values", {})
        risk_flags = chunk.get("risk_flags", [])
        confidence = chunk.get("confidence", 1.0)
        page_start = chunk.get("page_start")
        page_end = chunk.get("page_end")
        truncated = chunk.get("truncated", False)
        
        seen_categories.add(clause_hint)
        
        # Create processed chunk data
        processed_chunk = {
            "clause_hint": clause_hint,
            "key_values": key_values,
            "risk_flags": risk_flags,
            "confidence": confidence,
            "page_range": _format_page_range(page_start, page_end),
            "truncated": truncated
        }
        
        # Categorize chunk
        section_key = _categorize_chunk(clause_hint)
        sections[section_key].append(processed_chunk)
        
        # Collect medium and high risks only
        for risk in risk_flags:
            if risk.get("risk_level", "").lower() in ["medium", "high"]:
                risk_with_context = {
                    "clause_hint": clause_hint,
                    "page_range": _format_page_range(page_start, page_end),
                    **risk
                }
                all_risks.append(risk_with_context)
    
    # Build plain text summary
    summary = "LEASE SUMMARY\n\n"
    
    # Section 1: Lease Overview
    summary += "LEASE OVERVIEW\n"
    summary += _format_plain_text_section(sections["overview"], "lease overview")
    summary += "\n"
    
    # Section 2: Lease Term
    summary += "LEASE TERM\n"
    summary += _format_plain_text_section(sections["term"], "lease term")
    summary += "\n"
    
    # Section 3: Rent & Financials
    summary += "RENT & FINANCIALS\n"
    summary += _format_plain_text_section(sections["rent"], "rent and financial")
    summary += "\n"
    
    # Section 4: Additional Charges
    summary += "ADDITIONAL CHARGES\n"
    summary += _format_plain_text_section(sections["additional"], "additional charges")
    summary += "\n"
    
    # Section 5: Maintenance & Improvements
    summary += "MAINTENANCE & IMPROVEMENTS\n"
    summary += _format_plain_text_section(sections["maintenance"], "maintenance and improvements")
    summary += "\n"
    
    # Section 6: Assignment & Subletting
    summary += "ASSIGNMENT & SUBLETTING\n"
    summary += _format_plain_text_section(sections["assignment"], "assignment and subletting")
    summary += "\n"
    
    # Section 7: Use of Premises
    summary += "USE OF PREMISES\n"
    summary += _format_plain_text_section(sections["use"], "use of premises")
    summary += "\n"
    
    # Section 8: Insurance & Risk
    summary += "INSURANCE & RISK\n"
    summary += _format_plain_text_section(sections["insurance"], "insurance and risk")
    summary += "\n"
    
    # Section 9: Casualty & Access
    summary += "CASUALTY & ACCESS\n"
    summary += _format_plain_text_section(sections["casualty"], "casualty and access")
    summary += "\n"
    
    # Section 10: Legal Provisions
    summary += "LEGAL PROVISIONS\n"
    summary += _format_plain_text_section(sections["legal"], "legal clauses")
    summary += "\n"
    
    # Include miscellaneous section if it has content
    if sections["other"]:
        summary += "MISCELLANEOUS\n"
        summary += _format_plain_text_section(sections["other"], "miscellaneous clauses")
        summary += "\n"
    
    # Section 11: Risk Summary
    summary += "RISK SUMMARY\n"
    summary += _format_plain_text_risks(all_risks)
    summary += "\n"
    
    # Section 12: Missing Clauses
    summary += "MISSING CLAUSES\n"
    summary += _format_plain_text_missing_clauses(seen_categories)
    
    return summary


def generate_csv_rows(chunks: List[Dict[str, Any]]) -> List[List[str]]:
    """
    Generate CSV-compatible rows from enriched chunks for export.
    
    Args:
        chunks: List of enriched chunk dictionaries from the GPT chunker
        
    Returns:
        List of lists where each inner list represents a CSV row with headers
    """
    # Define CSV headers exactly as requested
    headers = [
        "Section", 
        "Clause Category", 
        "Key", 
        "Value", 
        "Risk Level", 
        "Description", 
        "Confidence", 
        "Page Range", 
        "Truncated?"
    ]
    
    # Initialize with headers
    rows = [headers]
    
    if not chunks:
        return rows
    
    # Process each chunk
    for chunk in chunks:
        clause_hint = chunk.get("clause_hint", "unknown")
        key_values = chunk.get("key_values", {})
        risk_flags = chunk.get("risk_flags", [])
        confidence = chunk.get("confidence", 1.0)
        page_start = chunk.get("page_start")
        page_end = chunk.get("page_end")
        truncated = chunk.get("truncated", False)
        
        # Format common fields
        section = _get_section_name_for_csv(_categorize_chunk(clause_hint))
        clause_category = clause_hint.replace("_", " ").title()
        confidence_str = f"{confidence:.2f}" if confidence is not None else "None"
        page_range = _format_page_range(page_start, page_end)
        truncated_str = "True" if truncated else "False"
        
        # Process key_values - one row per key-value pair
        if key_values:
            for key, value in key_values.items():
                clean_key = str(key).replace("_", " ").title()
                clean_value = str(value) if value is not None else "None"
                
                # Check if this key has associated risks
                associated_risk = _find_associated_risk(risk_flags, key)
                
                if associated_risk:
                    risk_level = associated_risk.get("risk_level", "None")
                    risk_description = associated_risk.get("description", "None")
                else:
                    risk_level = "None"
                    risk_description = "None"
                
                row = [
                    section,
                    clause_category,
                    clean_key,
                    clean_value,
                    risk_level,
                    risk_description,
                    confidence_str,
                    page_range,
                    truncated_str
                ]
                rows.append(row)
        
        # Process standalone risk_flags (when no key_values exist)
        elif risk_flags:
            for risk in risk_flags:
                risk_level = risk.get("risk_level", "unknown")
                risk_description = risk.get("description", "No description provided")
                
                row = [
                    section,
                    clause_category,
                    "Risk Flag",
                    "See Description",
                    risk_level,
                    risk_description,
                    confidence_str,
                    page_range,
                    truncated_str
                ]
                rows.append(row)
        
        # Create a row even if no key_values or risks (to show clause presence)
        else:
            row = [
                section,
                clause_category,
                "General",
                "Clause identified but no specific values extracted",
                "None",
                "None",
                confidence_str,
                page_range,
                truncated_str
            ]
            rows.append(row)
    
    return rows


def _format_plain_text_section(chunks: List[Dict[str, Any]], section_description: str) -> str:
    """
    Format section content as plain text without markdown.
    
    Args:
        chunks: List of processed chunks for this section
        section_description: Description of the section for empty state message
        
    Returns:
        Plain text content for the section
    """
    if not chunks:
        return f"No {section_description} information found.\n"
    
    content = ""
    
    for chunk in chunks:
        clause_hint = chunk["clause_hint"]
        key_values = chunk["key_values"]
        risk_flags = chunk["risk_flags"]
        confidence = chunk["confidence"]
        page_range = chunk["page_range"]
        
        # Add clause type
        content += f"\n{clause_hint.replace('_', ' ').title()}:\n"
        
        # Add key-value pairs
        if key_values:
            for key, value in key_values.items():
                clean_key = key.replace("_", " ").title()
                line = f"  - {clean_key}: {value}"
                
                # Add confidence indicator if low
                if confidence < 0.5:
                    line += " (please verify wording)"
                
                content += line + "\n"
        else:
            content += "  - No specific values extracted\n"
        
        # Add medium/high risk flags only
        relevant_risks = [r for r in risk_flags if r.get("risk_level", "").lower() in ["medium", "high"]]
        if relevant_risks:
            content += "  Risks:\n"
            for risk in relevant_risks:
                risk_level = risk.get("risk_level", "unknown")
                description = risk.get("description", "No description provided")
                content += f"    - {risk_level.upper()}: {description}\n"
        
        # Add page reference
        if page_range != "None":
            content += f"  (Pages {page_range})\n"
    
    return content


def _format_plain_text_risks(all_risks: List[Dict[str, Any]]) -> str:
    """
    Format risk warnings as plain text with deduplication by clause.
    
    Args:
        all_risks: List of all risk flags from all chunks (medium/high only)
        
    Returns:
        Plain text risk summary
    """
    if not all_risks:
        return "No medium or high priority risks identified.\n"
    
    # Group risks by clause to consolidate duplicates
    risks_by_clause = {}
    for risk in all_risks:
        clause = risk.get("clause_hint", "unknown")
        if clause not in risks_by_clause:
            risks_by_clause[clause] = []
        risks_by_clause[clause].append(risk)
    
    # Categorize consolidated risks by level
    high_priority_clauses = []
    medium_priority_clauses = []
    
    for clause, clause_risks in risks_by_clause.items():
        # Get the highest risk level for this clause
        max_level = "low"
        for risk in clause_risks:
            level = risk.get("risk_level", "").lower()
            if level == "high":
                max_level = "high"
                break
            elif level == "medium":
                max_level = "medium"
        
        # Consolidate descriptions
        descriptions = []
        seen_descriptions = set()
        for risk in clause_risks:
            desc = risk.get("description", "")
            # Normalize description to avoid near-duplicates
            normalized = desc.lower().strip()
            if normalized and normalized not in seen_descriptions:
                descriptions.append(desc)
                seen_descriptions.add(normalized)
        
        # Get page info from first risk
        page_range = clause_risks[0].get("page_range", "") if clause_risks else ""
        
        consolidated_risk = {
            "clause": clause.replace("_", " ").title(),
            "descriptions": descriptions,
            "page_range": page_range,
            "level": max_level
        }
        
        if max_level == "high":
            high_priority_clauses.append(consolidated_risk)
        elif max_level == "medium":
            medium_priority_clauses.append(consolidated_risk)
    
    content = ""
    
    # High priority risks first
    if high_priority_clauses:
        content += "\nHigh Priority Risks:\n"
        for risk in high_priority_clauses:
            clause_name = risk["clause"]
            descriptions = risk["descriptions"]
            page_range = risk["page_range"]
            page_info = f" (Page {page_range})" if page_range != "None" else ""
            
            # Combine multiple descriptions with semicolons
            combined_desc = "; ".join(descriptions)
            content += f"  - {clause_name}: {combined_desc}{page_info}\n"
    
    # Medium priority risks
    if medium_priority_clauses:
        content += "\nMedium Priority Risks:\n"
        for risk in medium_priority_clauses:
            clause_name = risk["clause"]
            descriptions = risk["descriptions"]
            page_range = risk["page_range"]
            page_info = f" (Page {page_range})" if page_range != "None" else ""
            
            # Combine multiple descriptions with semicolons
            combined_desc = "; ".join(descriptions)
            content += f"  - {clause_name}: {combined_desc}{page_info}\n"
    
    # Add summary
    content += f"\nTotal: {len(high_priority_clauses)} high priority, {len(medium_priority_clauses)} medium priority risks identified.\n"
    
    return content


def _format_plain_text_missing_clauses(seen_categories: Set[str]) -> str:
    """
    Format missing clauses section as plain text.
    
    Args:
        seen_categories: Set of clause categories that were found in the document
        
    Returns:
        Plain text missing clauses content
    """
    # Define essential lease clauses
    essential_clauses = {
        "premises": "Premises Description",
        "term": "Lease Term",
        "rent": "Base Rent",
        "maintenance": "Maintenance Responsibilities",
        "use": "Use of Premises", 
        "assignment": "Assignment & Subletting",
        "insurance": "Insurance Requirements",
        "default": "Default & Remedies",
        "casualty": "Casualty & Damage",
        "entry": "Landlord Entry Rights",
        "eminent_domain": "Eminent Domain/Condemnation",
        "notices": "Notice Provisions",
        "governing_law": "Governing Law"
    }
    
    missing_clauses = []
    
    # Check each essential clause
    for clause_key, display_name in essential_clauses.items():
        found = any(clause_key in cat.lower() for cat in seen_categories)
        if not found:
            missing_clauses.append(display_name)
    
    # Format output
    if not missing_clauses:
        return "All essential lease clauses appear to be present.\n"
    
    content = "The following important lease clauses were not found:\n"
    for clause in missing_clauses:
        content += f"  - {clause}\n"
    
    content += "\nNote: These clauses may be present but not recognized, or embedded within other sections.\n"
    
    return content


def _categorize_chunk(clause_hint: str) -> str:
    """
    Categorize a clause hint into the appropriate section key.
    
    Args:
        clause_hint: The clause hint from the chunk
        
    Returns:
        Section key for the sections dictionary
    """
    hint = clause_hint.lower()
    
    # Lease Overview: premises, parties, property details
    if any(term in hint for term in ["premises", "landlord", "tenant", "property", "address", "building", "location"]):
        return "overview"
    
    # Lease Term: duration, dates, commencement, expiration
    elif any(term in hint for term in ["term", "commencement", "expiration", "duration", "lease_period"]):
        return "term"
    
    # Rent & Financials: base rent, minimum rent, payment terms
    elif any(term in hint for term in ["rent", "payment", "base_rent", "minimum_rent", "monthly_rent"]):
        return "rent"
    
    # Additional Charges: CAM, taxes, utilities, operating expenses
    elif any(term in hint for term in ["additional_rent", "cam", "common_area", "operating_expenses", "taxes", "utilities", "escalation"]):
        return "additional"
    
    # Maintenance & Improvements: repairs, alterations, improvements
    elif any(term in hint for term in ["maintenance", "repair", "improvements", "alterations", "tenant_improvements", "buildout"]):
        return "maintenance"
    
    # Assignment & Subletting: transfer rights, subletting
    elif any(term in hint for term in ["assignment", "sublet", "transfer", "subletting", "assignability"]):
        return "assignment"
    
    # Use of Premises: permitted use, restrictions, exclusivity
    elif any(term in hint for term in ["use", "permitted_use", "prohibited_use", "exclusive", "exclusivity", "business_use"]):
        return "use"
    
    # Insurance & Risk: liability, property insurance, indemnity
    elif any(term in hint for term in ["insurance", "liability", "indemnity", "indemnification", "coverage"]):
        return "insurance"
    
    # Casualty & Access: damage, destruction, entry, eminent domain
    elif any(term in hint for term in ["casualty", "damage", "destruction", "entry", "access", "eminent_domain", "condemnation"]):
        return "casualty"
    
    # Legal Clauses: default, remedies, notices, governing law
    elif any(term in hint for term in ["default", "remedies", "legal", "notices", "dispute", "governing_law", "jurisdiction"]):
        return "legal"
    
    # Everything else goes to other
    else:
        return "other"


def _format_page_range(page_start: Any, page_end: Any) -> str:
    """
    Format page range for display in both markdown and CSV outputs.
    
    Args:
        page_start: Starting page number
        page_end: Ending page number
        
    Returns:
        Formatted page range string
    """
    if page_start is None and page_end is None:
        return "None"
    elif page_start is None:
        return f"–{page_end}" if page_end else "None"
    elif page_end is None:
        return f"{page_start}–" if page_start else "None"
    elif page_start == page_end:
        return str(page_start)
    else:
        return f"{page_start}–{page_end}"


def _get_section_name_for_csv(section_key: str) -> str:
    """
    Convert section key to human-readable section name for CSV export.
    
    Args:
        section_key: Internal section key
        
    Returns:
        Human-readable section name
    """
    section_map = {
        "overview": "Lease Overview",
        "term": "Lease Term", 
        "rent": "Rent & Financials",
        "additional": "Additional Charges",
        "maintenance": "Maintenance & Improvements",
        "assignment": "Assignment & Subletting",
        "use": "Use of Premises",
        "insurance": "Insurance & Risk",
        "casualty": "Casualty & Access",
        "legal": "Legal Clauses",
        "other": "Miscellaneous"
    }
    
    return section_map.get(section_key, "Unknown")


def _find_associated_risk(risk_flags: List[Dict[str, Any]], key: str) -> Dict[str, Any]:
    """
    Find a risk flag that might be associated with a specific key.
    
    Args:
        risk_flags: List of risk flags for the chunk
        key: The key to find associated risks for
        
    Returns:
        Associated risk dictionary or empty dict if none found
    """
    if not risk_flags:
        return {}
    
    key_lower = str(key).lower()
    
    # Look for risks that mention the key in their description
    for risk in risk_flags:
        description = risk.get("description", "").lower()
        if key_lower in description or any(part in description for part in key_lower.split("_")):
            return risk
    
    # If no specific match, return the first risk (assuming it's related)
    return risk_flags[0] if len(risk_flags) == 1 else {}


def test_summary_module():
    """
    Test function to demonstrate both summary generation functions with sample data.
    """
    print("Testing LeaseLogic Summary Generator V2")
    print("=" * 50)
    
    # Sample enriched chunks (2-3 as requested)
    sample_chunks = [
        {
            "chunk_id": "R-001",
            "clause_hint": "rent",
            "key_values": {
                "base_rent": "$25,000/month",
                "escalation_rate": "3% annually",
                "payment_due_date": "1st of each month"
            },
            "risk_flags": [
                {
                    "risk_level": "medium",
                    "description": "No cap specified on annual rent escalations"
                }
            ],
            "confidence": 0.92,
            "page_start": 4,
            "page_end": 5,
            "truncated": False
        },
        {
            "chunk_id": "A-001",
            "clause_hint": "assignment",
            "key_values": {
                "assignment_allowed": "With prior written consent",
                "consent_standard": "Not to be unreasonably withheld"
            },
            "risk_flags": [
                {
                    "risk_level": "high", 
                    "description": "Broad landlord discretion in assignment approval"
                }
            ],
            "confidence": 0.45,  # Low confidence example
            "page_start": 8,
            "page_end": 8,
            "truncated": True
        },
        {
            "chunk_id": "I-001",
            "clause_hint": "insurance",
            "key_values": {
                "general_liability": "$2,000,000 per occurrence",
                "property_coverage": "Full replacement cost"
            },
            "risk_flags": [],
            "confidence": 0.91,
            "page_start": 12,
            "page_end": 13,
            "truncated": False
        }
    ]
    
    print("\n1. Testing Summary Generation:")
    print("-" * 40)
    
    summary = generate_markdown_summary(sample_chunks)
    print(summary)
    
    print("\n2. Testing CSV Row Generation:")
    print("-" * 40)
    
    csv_rows = generate_csv_rows(sample_chunks)
    
    # Print CSV rows
    for i, row in enumerate(csv_rows):
        if i == 0:
            print("HEADERS:", row)
        else:
            print(f"ROW {i}:", row)
    
    print(f"\nTotal CSV rows: {len(csv_rows)}")
    print("\nTest completed successfully!")


# Run test if this module is executed directly
if __name__ == "__main__":
    test_summary_module()
